{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-d737b16b-fc9d-4b0e-b1b9-cd422839f383",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code or cause a denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `cpu_mem[Mat::E::C]` to `C_abs.data()`. If the size of `cpu_mem[Mat::E::C]` (defined by `mem_size[Mem::E::C]`) is larger than the size of `C_abs.data()`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative, such as `std::copy` or `std::copy_n`, which checks the size of the destination buffer.\n\n```cpp\nstd::copy(cpu_mem[Mat::E::C], cpu_mem[Mat::E::C] + mem_size[Mem::E::C], C_abs.data());\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memcpy`\n- `<algorithm>` for `std::copy`\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3380cc8f-1ce5-4d0c-8e21-44d947f0f3f0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `memsize(Mat::E::C)` is larger than the size of `C_abs.data()`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = memsize(Mat::E::C);\nif (size <= C_abs.size()) {\n    memcpy(C_abs.data(), c_mem0.data(), size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the data being copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code snippet appears to use the following libraries:\n\n- A library that provides the `memcpy` function, such as `<cstring>` in C++.\n- A library that provides the `memsize` function. This function is not standard in C++, so it's likely part of a custom library.\n- A library that provides the `Mat::E::C` object. This is also likely part of a custom library.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cab1fcd6-b407-4b73-bd38-78ee317155d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(A_abs.data(), cpu_mem[Mat::E::A], mem_size[Mem::E::A])\n```\n\nThe `memcpy` function is copying data from `cpu_mem[Mat::E::A]` to `A_abs.data()`. If `mem_size[Mem::E::A]` is larger than the size of `A_abs.data()`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (mem_size[Mem::E::A] <= A_abs.size()) {\n    memcpy(A_abs.data(), cpu_mem[Mat::E::A], mem_size[Mem::E::A]);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if `A_abs` is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the application.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>` or `<array>`: These libraries could provide the `data` method used on `A_abs`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-23c44a41-561c-48f1-a5bb-920b2db903fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `ptr_cmb->r_mem[Mat::E::B]` to `B_abs.data()`. If the size of `B_abs.data()` is less than `memsize(Mat::E::B)`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `memcpy_s`:\n\n```cpp\nsize_t size = memsize(Mat::E::B);\nif (size <= B_abs.size()) {\n    memcpy_s(B_abs.data(), size, ptr_cmb->r_mem[Mat::E::B], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code snippet appears to depend on the following libraries:\n\n- A library that provides the `memcpy` function, such as `<cstring>` in C++.\n- A library that provides the `B_abs` and `ptr_cmb` objects and the `memsize` function. The specific library would depend on the context in which this code is used.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0230816c-89df-4724-a97e-f2ae93e87e2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (B_abs.size() >= mem_size[Mem::E::B]) {\n    memcpy(B_abs.data(), cpu_mem[Mat::E::B], mem_size[Mem::E::B]);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `B_abs` is greater than or equal to `mem_size[Mem::E::B]`. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>` or `<array>`: These libraries could provide the `data()` method, assuming `B_abs` is a standard C++ container.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ba00c5f2-89fc-46aa-a946-0690eabc5bb9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if `mem_size[Mem::E::C]` is larger than the size of `c_copy.data()`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (c_copy.size() >= mem_size[Mem::E::C]) {\n    memcpy(c_copy.data(), cpu_mem[Mem::E::C], mem_size[Mem::E::C]);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fix, we check if `c_copy` is large enough to hold the data being copied before calling `memcpy`.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>` or `<array>`: These libraries could provide the `c_copy` object, depending on its type.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5ef0d67a-8583-46db-8f55-e72fcbecfb22",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes size checks. For example:\n\n```cpp\nif (memsize(Mat::E::A) <= A_abs.size()) {\n    memcpy(A_abs.data(), ptr_cmb->r_mem[Mat::E::A], memsize(Mat::E::A));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<vector>` or `<array>`: if `A_abs` is a standard C++ container\n- Custom libraries or headers defining `Mat::E::A`, `ptr_cmb`, `r_mem`, and `memsize`\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ba6069c4-8c1b-405f-ba22-9ff7681f09a9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow, or cause denial-of-service conditions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `strncat`, `snprintf`, etc., are safer alternatives as they take the size of the destination buffer as an argument and ensure that it is not overrun.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative. For example, you can use `std::copy` from the `<algorithm>` library, which is safer as it works with iterators rather than raw pointers.\n\n```cpp\nstd::copy(ptr_cmb->r_mem[Mat::E::C], ptr_cmb->r_mem[Mat::E::C] + memsize(Mat::E::C), c_mem0.data());\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<algorithm>` for `std::copy`\n- `<vector>` or `<array>` for `c_mem0.data()`\n- Custom libraries or classes for `ptr_cmb->r_mem[Mat::E::C]` and `memsize(Mat::E::C)`\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-df9a6152-6d1f-4dc0-a296-1a0a42591020",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-115f5d5e-0ff0-4f41-b4d1-591b41d0585d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes buffer size checks. For example:\n\n```cpp\nif (mem_size[Mem::E::C] <= c_for_cpu_compute.size()) {\n    memcpy(c_for_cpu_compute.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C]);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<vector>` or `<array>`: if `c_for_cpu_compute` is a standard C++ container\n- Any libraries required by `Mat::E::C`, `Mem::E::C`, and `cpu_mem`\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-786: Access of Memory Location Before Start of Buffer](https://cwe.mitre.org/data/definitions/786.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-24cdfea4-490b-44cf-915b-b5a11ddf9a5a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially when randomness is required for security purposes. The `rand()` function, which relies on `RAND_MAX`, is a common example of a non-cryptographic random number generator. It is predictable and not suitable for cryptographic purposes, such as generating keys, tokens, or any other security-sensitive data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which are more suitable for generating random numbers in a secure manner.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here's an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++11-compliant compiler.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-ceaf11ed-41ca-4ee9-9c86-73be61454ab4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-de1322e3-b46d-4a59-893d-cf6856dc0eac",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-b7ee6022-25d4-4bff-b3f1-b12ff19ce741",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially in security-sensitive applications. Functions like `rand()` from the C standard library are not suitable for cryptographic purposes because they produce predictable sequences of numbers. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, but for cryptographic purposes, consider using libraries like OpenSSL or libsodium that offer cryptographically secure random number generation.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdlib> // For rand()\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_shuffle(vec.begin(), vec.end());\n}\n```\n\n#### Fixed Code\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <random> // For std::random_device and std::mt19937\n\nvoid shuffleVector(std::vector<int>& vec) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(vec.begin(), vec.end(), g);\n}\n```\n\n### Library Dependencies\n\n- `<algorithm>`: Required for `std::shuffle`.\n- `<vector>`: Required for using `std::vector`.\n- `<random>`: Required for `std::random_device` and `std::mt19937`.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-79e4502e-e8a4-446a-b224-2224e2bdcdb6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-59fa650a-2173-4754-95a0-e87ff7779bf6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-d737b16b-fc9d-4b0e-b1b9-cd422839f383",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/tinyone.cpp"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 7,
                  "endLine": 294,
                  "endColumn": 68,
                  "charOffset": 9441,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(C_abs.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C])",
                    "rendered": {
                      "text": "memcpy(C_abs.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C])",
                      "markdown": "`memcpy(C_abs.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/tinyone.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9441,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(C_abs.data(), <size of C_abs.data()>,  cpu_mem[Mat::E::C],  mem_size[Mem::E::C])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3380cc8f-1ce5-4d0c-8e21-44d947f0f3f0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/apitest.cpp"
                },
                "region": {
                  "startLine": 414,
                  "startColumn": 11,
                  "endLine": 414,
                  "endColumn": 65,
                  "charOffset": 14016,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(C_abs.data(), c_mem0.data(), memsize(Mat::E::C)",
                    "rendered": {
                      "text": "memcpy(C_abs.data(), c_mem0.data(), memsize(Mat::E::C)",
                      "markdown": "`memcpy(C_abs.data(), c_mem0.data(), memsize(Mat::E::C)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/apitest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14016,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(C_abs.data(), <size of C_abs.data()>,  c_mem0.data(),  memsize(Mat::E::C)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cab1fcd6-b407-4b73-bd38-78ee317155d8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/tinyone.cpp"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 7,
                  "endLine": 280,
                  "endColumn": 68,
                  "charOffset": 9071,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(A_abs.data(), cpu_mem[Mat::E::A], mem_size[Mem::E::A])",
                    "rendered": {
                      "text": "memcpy(A_abs.data(), cpu_mem[Mat::E::A], mem_size[Mem::E::A])",
                      "markdown": "`memcpy(A_abs.data(), cpu_mem[Mat::E::A], mem_size[Mem::E::A])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/tinyone.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9071,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(A_abs.data(), <size of A_abs.data()>,  cpu_mem[Mat::E::A],  mem_size[Mem::E::A])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-23c44a41-561c-48f1-a5bb-920b2db903fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/apitest.cpp"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 11,
                  "endLine": 407,
                  "endColumn": 77,
                  "charOffset": 13806,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(B_abs.data(), ptr_cmb->r_mem[Mat::E::B], memsize(Mat::E::B)",
                    "rendered": {
                      "text": "memcpy(B_abs.data(), ptr_cmb->r_mem[Mat::E::B], memsize(Mat::E::B)",
                      "markdown": "`memcpy(B_abs.data(), ptr_cmb->r_mem[Mat::E::B], memsize(Mat::E::B)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/apitest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13806,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(B_abs.data(), <size of B_abs.data()>,  ptr_cmb->r_mem[Mat::E::B],  memsize(Mat::E::B)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0230816c-89df-4724-a97e-f2ae93e87e2f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/tinyone.cpp"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 7,
                  "endLine": 287,
                  "endColumn": 68,
                  "charOffset": 9256,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(B_abs.data(), cpu_mem[Mat::E::B], mem_size[Mem::E::B])",
                    "rendered": {
                      "text": "memcpy(B_abs.data(), cpu_mem[Mat::E::B], mem_size[Mem::E::B])",
                      "markdown": "`memcpy(B_abs.data(), cpu_mem[Mat::E::B], mem_size[Mem::E::B])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/tinyone.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9256,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(B_abs.data(), <size of B_abs.data()>,  cpu_mem[Mat::E::B],  mem_size[Mem::E::B])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ba00c5f2-89fc-46aa-a946-0690eabc5bb9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/tinyone.cpp"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 7,
                  "endLine": 62,
                  "endColumn": 69,
                  "charOffset": 1699,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(c_copy.data(), cpu_mem[Mem::E::C], mem_size[Mem::E::C])",
                    "rendered": {
                      "text": "memcpy(c_copy.data(), cpu_mem[Mem::E::C], mem_size[Mem::E::C])",
                      "markdown": "`memcpy(c_copy.data(), cpu_mem[Mem::E::C], mem_size[Mem::E::C])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/tinyone.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1699,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c_copy.data(), <size of c_copy.data()>,  cpu_mem[Mem::E::C],  mem_size[Mem::E::C])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5ef0d67a-8583-46db-8f55-e72fcbecfb22",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/apitest.cpp"
                },
                "region": {
                  "startLine": 400,
                  "startColumn": 11,
                  "endLine": 400,
                  "endColumn": 77,
                  "charOffset": 13596,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(A_abs.data(), ptr_cmb->r_mem[Mat::E::A], memsize(Mat::E::A)",
                    "rendered": {
                      "text": "memcpy(A_abs.data(), ptr_cmb->r_mem[Mat::E::A], memsize(Mat::E::A)",
                      "markdown": "`memcpy(A_abs.data(), ptr_cmb->r_mem[Mat::E::A], memsize(Mat::E::A)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/apitest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13596,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(A_abs.data(), <size of A_abs.data()>,  ptr_cmb->r_mem[Mat::E::A],  memsize(Mat::E::A)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ba6069c4-8c1b-405f-ba22-9ff7681f09a9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/apitest.cpp"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 7,
                  "endLine": 118,
                  "endColumn": 74,
                  "charOffset": 3346,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(c_mem0.data(), ptr_cmb->r_mem[Mat::E::C], memsize(Mat::E::C)",
                    "rendered": {
                      "text": "memcpy(c_mem0.data(), ptr_cmb->r_mem[Mat::E::C], memsize(Mat::E::C)",
                      "markdown": "`memcpy(c_mem0.data(), ptr_cmb->r_mem[Mat::E::C], memsize(Mat::E::C)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/apitest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3346,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c_mem0.data(), <size of c_mem0.data()>,  ptr_cmb->r_mem[Mat::E::C],  memsize(Mat::E::C)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-df9a6152-6d1f-4dc0-a296-1a0a42591020",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/initialisationdemo.cpp"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 16,
                  "endLine": 41,
                  "endColumn": 24,
                  "charOffset": 1012,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-115f5d5e-0ff0-4f41-b4d1-591b41d0585d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/tinyone.cpp"
                },
                "region": {
                  "startLine": 265,
                  "startColumn": 7,
                  "endLine": 265,
                  "endColumn": 80,
                  "charOffset": 8493,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(c_for_cpu_compute.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C])",
                    "rendered": {
                      "text": "memcpy(c_for_cpu_compute.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C])",
                      "markdown": "`memcpy(c_for_cpu_compute.data(), cpu_mem[Mat::E::C], mem_size[Mem::E::C])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "miopengemm/src/tinyone.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8493,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c_for_cpu_compute.data(), <size of c_for_cpu_compute.data()>,  cpu_mem[Mat::E::C],  mem_size[Mem::E::C])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-24cdfea4-490b-44cf-915b-b5a11ddf9a5a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/initialisationdemo.cpp"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 76,
                  "endLine": 49,
                  "endColumn": 84,
                  "charOffset": 1171,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ceaf11ed-41ca-4ee9-9c86-73be61454ab4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/initialisationdemo.cpp"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 47,
                  "endLine": 49,
                  "endColumn": 52,
                  "charOffset": 1142,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-de1322e3-b46d-4a59-893d-cf6856dc0eac",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/initialisationdemo.cpp"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 16,
                  "endLine": 41,
                  "endColumn": 21,
                  "charOffset": 1012,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b7ee6022-25d4-4bff-b3f1-b12ff19ce741",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "miopengemm/src/graph.cpp"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 14,
                  "endLine": 43,
                  "endColumn": 22,
                  "charOffset": 1273,
                  "charLength": 8,
                  "snippet": {
                    "text": "shuffle(",
                    "rendered": {
                      "text": "shuffle(",
                      "markdown": "`shuffle(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-79e4502e-e8a4-446a-b224-2224e2bdcdb6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/multifind.cpp"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 44,
                  "endLine": 64,
                  "endColumn": 52,
                  "charOffset": 1823,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-59fa650a-2173-4754-95a0-e87ff7779bf6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/apidriver.cpp"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 30,
                  "endLine": 72,
                  "endColumn": 35,
                  "charOffset": 1835,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}